% !TEX program = lualatex
\documentclass[aspectratio=169,professionalfonts]{beamer}
\input{../preamble.tex}
\usepackage{mwe}

\title[ClústerLab • Día 3]{Lo escencial en Python}
\subtitle{Codigos simples, distribuir carga}
\author{Equipo docente ClústerLab}
\date{8 de agosto de 2025}

\begin{document}

%------------------------------ portada ----------------------------
\begin{frame}[plain]
  \titlepage
\end{frame}

%---------------------------- OBJETIVOS ----------------------------
\begin{frame}{Objetivos de la sesión}
\begin{itemize}
  \item Entender lo esencial de Python 3: variables, tipos, control de flujo, funciones, listas y diccionarios.
  \item Ejecutar scripts en terminal (Linux/WSL) y usar un entorno virtual simple.
  \item Ver un ejemplo \textbf{muy simple} de paralelismo con \texttt{concurrent.futures.ProcessPoolExecutor}.
  \item Mostrar mini-ejemplos \emph{orientados a carrera}: Biomédica, Telecomunicaciones, Mecatrónica y Física.
  \item Dejar tareas base para complejizar luego y migrar a Leftraru (próximas sesiones).
\end{itemize}
\end{frame}

%---------------------------- PRE-REQUISITOS ----------------------------
\begin{frame}[fragile]{Pre-requisitos rápidos}
\textbf{Opción WSL/Ubuntu (Windows) o Linux nativo}
\begin{minted}{bash}
# Ver versión de Python
python3 --version

# Crear y activar venv
python3 -m venv .venv
source .venv/bin/activate   # en PowerShell:  .venv\Scripts\Activate.ps1

# Instalar paquetes cuando se pidan (ej: numpy, matplotlib)
pip install --upgrade pip
\end{minted}
\end{frame}

%---------------------------- HOLA MUNDO ----------------------------
\begin{frame}[fragile]{Lo mínimo indispensable}
\begin{minted}{python}
print("Hola, ClústerLab!")  # salida en consola
\end{minted}

\textbf{Ejecutar:}
\begin{minted}{bash}
python3 hola.py
\end{minted}
\end{frame}

%---------------------------- VARIABLES Y TIPOS ----------------------------
\begin{frame}[fragile]{Variables y tipos comunes}
\begin{minted}{python}
a = 5                      # entero
b = 2.5                    # float
c = "ITM"                  # string
ok = True                  # booleano
nums = [1, 2, 3]           # lista
punto = (3, 4)             # tupla
info = {"curso": "D04", "anio": 2025}  # dict

print(f"a={a}, b={b}, c={c}")
print("len(nums) =", len(nums))
print("curso:", info["curso"])
\end{minted}
\end{frame}

%---------------------------- CONTROL DE FLUJO ----------------------------
\begin{frame}[fragile]{Control de flujo (if / for / while)}
\begin{minted}{python}
x = 7
if x % 2 == 0:
    print("par")
else:
    print("impar")

for k in ["a", "b", "c"]:
    print(k)

i = 0
while i < 3:
    print("i =", i)
    i += 1
\end{minted}
\end{frame}

%---------------------------- FUNCIONES ----------------------------
\begin{frame}[fragile]{Funciones}
\begin{minted}{python}
def area_rectangulo(base: float, altura: float) -> float:
    """Devuelve el área de un rectángulo."""
    return base * altura

print(area_rectangulo(3, 5))  # 15
\end{minted}
\end{frame}

%---------------------------- LISTAS Y DICCIONARIOS ----------------------------
\begin{frame}[fragile]{Listas y diccionarios}
\begin{minted}{python}
valores = [10, 20, 30]
valores.append(40)
cuadrados = [v*v for v in valores]  # list comprehension

persona = {"nombre": "Ana", "edad": 21}
persona["edad"] += 1
for clave, valor in persona.items():
    print(clave, "->", valor)
\end{minted}
\end{frame}

%---------------------------- PLOTEO RÁPIDO ----------------------------
\begin{frame}[fragile]{Un gráfico en 5 líneas (numpy + matplotlib)}
\begin{minted}{python}
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 2*np.pi, 200)
y = np.sin(2*x)
plt.plot(x, y); plt.xlabel("x"); plt.ylabel("sin(2x)"); plt.title("Demo")
plt.show()
\end{minted}
\end{frame}

%---------------------------- MINI-EJERCICIOS ----------------------------
\begin{frame}{Mini-ejercicios (10–15 min)}
\begin{enumerate}
  \item Escribe una función \texttt{promedio(lista)} y pruébala.
  \item Dada una lista de números, genera otra con los pares y otra con los impares.
  \item Crea un diccionario \texttt{\{"a":1,"b":2,...\}} y recórrelo imprimiendo \texttt{clave:valor}.
  \item Modifica el gráfico para mostrar \texttt{cos(x)} y guarda la figura como PNG.
\end{enumerate}
\end{frame}

%---------------------------- PARALELISMO (IDEA) ----------------------------
\begin{frame}{Paralelismo en 3 ideas}
\begin{itemize}
  \item \textbf{CPU-bound} (cálculo pesado) \(\Rightarrow\) procesos (\texttt{multiprocessing}/\texttt{ProcessPoolExecutor}).
  \item \textbf{I/O-bound} (esperas) \(\Rightarrow\) \texttt{asyncio} o \texttt{ThreadPoolExecutor}.
  \item Hoy: un \textbf{mini} ejemplo CPU-bound con procesos.
\end{itemize}
\end{frame}

%----------- CONTEXTO: MONTE CARLO π (SECUENCIAL Y EN PARALELO) --------------
\begin{frame}{Monte Carlo para \(\pi\): por qué este ejemplo}
\begin{itemize}
  \item \textbf{Intención}: problema \textbf{independiente por muestra}, ideal para dividir en \emph{chunks} y sumar resultados.
  \item \textbf{Aplicabilidad}: patrones típicos en simulación/ML: promedio de muchas corridas, estimadores por muestreo.
  \item \textbf{Claves}: semillas por proceso para reproducibilidad; balancear tamaño de \emph{chunk} vs costo de crear procesos.
  \item \textbf{A futuro}: medir \textit{speedup} y \textit{scaling}; convertir el cuerpo de trabajo en \texttt{srun} sobre múltiples nodos.
\end{itemize}
\end{frame}


%---------------------------- PARALELO: PI MONTE CARLO ----------------------------
\begin{frame}[fragile]{Ejemplo paralelo: \textit{Monte Carlo} para \(\pi\)}
\textbf{Versión secuencial:}
\begin{minted}{python}
import random, math

def inside():
    x, y = random.random(), random.random()
    return 1 if x*x + y*y <= 1.0 else 0

def pi_serial(n:int=2_000_000) -> float:
    hits = sum(inside() for _ in range(n))
    return 4.0 * hits / n

print("pi ~", pi_serial(1_000_000))
\end{minted}
\end{frame}

\begin{frame}[fragile]{Mismo cálculo con procesos (paralelo)}
\begin{minted}[fontsize=\tiny]{python}
from concurrent.futures import ProcessPoolExecutor
import os, time

def count_hits(m:int) -> int:
    import random
    h = 0
    for _ in range(m):
        x, y = random.random(), random.random()
        h += 1 if x*x + y*y <= 1.0 else 0
    return h

def pi_parallel(n:int=2_000_000, workers:int=os.cpu_count()) -> float:
    chunk = n // workers
    with ProcessPoolExecutor(max_workers=workers) as ex:
        parts = list(ex.map(count_hits, [chunk]*workers))
    hits = sum(parts)
    return 4.0 * hits / (chunk*workers)

t0=time.perf_counter(); p=pi_parallel(2_000_000); dt=time.perf_counter()-t0
print(f"pi ~ {p:.6f}  (workers={os.cpu_count()}, {dt:.3f}s)")
\end{minted}
\end{frame}

%---------------------------- EXPLICACIÓN BREVE ----------------------------
\begin{frame}{¿Qué está pasando?}
\begin{itemize}
  \item Dividimos \(N\) puntos en \(\texttt{workers}\) partes.
  \item Cada proceso \(\to\) calcula \# de aciertos en su porción (independiente).
  \item Sumamos resultados \(\to\) estimador de \(\pi\).
  \item Ventaja: \textbf{CPUs múltiples} trabajan en paralelo. 
  \item Nota: Cuidado con \textit{overhead} de procesos y tamaño de tareas.
\end{itemize}
\end{frame}

%---------------------------- ORIENTADO A CARRERAS ----------------------------
\begin{frame}{Snippets por área (para enganchar interés)}
Cuatro \textbf{códigos ultra simples} que luego escalaremos:
\begin{enumerate}
  \item Ingeniería Biomédica: Suavizado de señal 1D (ventana móvil).
  \item Telecomunicaciones: Promedio de potencia por antena (diccionarios).
  \item Mecatrónica: Lectura de sensor simulado y control ON/OFF.
  \item Física: Caminata aleatoria y distribución de posiciones.
\end{enumerate}
\end{frame}

%---------------------- CONTEXTO: BIOMÉDICA (SUAVIZADO) -----------------------
\begin{frame}{Biomédica — Por qué un promedio móvil}
\begin{itemize}
  \item \textbf{Intención}: reducir ruido de alta frecuencia para resaltar morfología (p.~ej., ondas ECG/PPG) sin sobrecargar teoría.
  \item \textbf{Aplicabilidad}: pre-procesamiento rápido antes de detección de picos, segmentación o cálculo de HR/HRV.
  \item \textbf{Claves}: elegir ventana \texttt{w} según frecuencia de muestreo; bordes (\texttt{mode='same'}) y \emph{latencia}.
  \item \textbf{A futuro}: comparar con Savitzky--Golay o filtros Butterworth (\texttt{scipy.signal}) y evaluar métricas SNR.
\end{itemize}
\end{frame}

%---------------------------- BIOMÉDICA ----------------------------
\begin{frame}[fragile]{Ingeniería Biomédica — Suavizado (moving average)}
\begin{minted}{python}
import numpy as np

def moving_average(x, w=5):
    x = np.asarray(x, dtype=float)
    w = max(1, int(w))
    kernel = np.ones(w)/w
    # 'same' mantiene largo; borde simple
    return np.convolve(x, kernel, mode='same')

# Demo con señal ruidosa sintética
t = np.linspace(0, 1, 200)
ecg = 1.0*np.sin(2*np.pi*5*t) + 0.3*np.random.randn(t.size)
ecg_suave = moving_average(ecg, w=7)
\end{minted}
\end{frame}

%-------------------- CONTEXTO: TELECOM (AGREGAR POR ANTENA) ------------------
\begin{frame}{Telecomunicaciones — Agregar métricas por antena}
\begin{itemize}
  \item \textbf{Intención}: agrupar registros por identificador y calcular promedios/estadísticos (RSSI, RSRP, etc.).
  \item \textbf{Aplicabilidad}: comparar desempeño por celda/sector, detectar outliers o degradación de cobertura.
  \item \textbf{Claves}: patrón “acumulador + contador” con \texttt{dict}; manejo de claves ausentes con \texttt{get}.
  \item \textbf{A futuro}: migrar a \texttt{pandas} (\texttt{groupby}) y mapear a coordenadas para \textit{heatmaps} de señal.
\end{itemize}
\end{frame}

%---------------------------- TELECOM ----------------------------
\begin{frame}[fragile]{Telecomunicaciones — Agregar por antena}
\begin{minted}{python}
registros = [
  {"antena":"A","rssi":-60},
  {"antena":"B","rssi":-70},
  {"antena":"A","rssi":-62},
  {"antena":"B","rssi":-68},
]

acum = {}
cont = {}
for r in registros:
    a = r["antena"]
    acum[a] = acum.get(a, 0) + r["rssi"]
    cont[a] = cont.get(a, 0) + 1

prom = {a:acum[a]/cont[a] for a in acum}
print(prom)  # {'A': -61.0, 'B': -69.0}
\end{minted}
\end{frame}

%---------------- CONTEXTO: MECATRÓNICA (CONTROL ON/OFF) ----------------------
\begin{frame}{Mecatrónica — Control ON/OFF con histéresis}
\begin{itemize}
  \item \textbf{Intención}: ilustrar un controlador básico para mantener una variable (temperatura) cerca del \textit{setpoint}.
  \item \textbf{Aplicabilidad}: termostatos, cámaras térmicas, incubadoras; lógica de \textbf{histeresis} reduce conmutaciones.
  \item \textbf{Claves}: definir bandas (\(\pm 0.2\)°C en el ejemplo); frecuencia de muestreo y ruido de sensor importan.
  \item \textbf{A futuro}: extender a \textbf{PID}, saturaciones y anti-\textit{windup}; simular planta con modelos discretos.
\end{itemize}
\end{frame}

%---------------------------- MECATRÓNICA ----------------------------
\begin{frame}[fragile]{Mecatrónica — Control ON/OFF (simulación sencilla)}
\begin{minted}{python}
setpoint = 25.0
lecturas = [23.0, 23.5, 24.0, 24.7, 25.2, 25.6, 24.9, 24.7]
salidas = []

for temp in lecturas:
    if temp < setpoint - 0.2:
        accion = "ENCENDER"  # calentar
    elif temp > setpoint + 0.2:
        accion = "APAGAR"
    else:
        accion = "MANTENER"
    salidas.append(accion)

print(salidas)
\end{minted}
\end{frame}

%---------------------- CONTEXTO: FÍSICA (RANDOM WALK) ------------------------
\begin{frame}{Física — Caminata aleatoria 1D: modelo mínimo de difusión}
\begin{itemize}
  \item \textbf{Intención}: mostrar un proceso estocástico simple cuyo RMS crece como \(\sqrt{n}\) (difusión clásica).
  \item \textbf{Aplicabilidad}: Browniano, polímeros, mercado simple; sirve para validar leyes de escala y CLT.
  \item \textbf{Claves}: múltiples corridas para distribución de posiciones; fijar semilla si se requiere reproducibilidad.
  \item \textbf{A futuro}: estimar $D$ a partir de \(\langle x^2\rangle\), extender a 2D/3D y paralelizar muchas trayectorias.
\end{itemize}
\end{frame}

%---------------------------- FÍSICA ----------------------------
\begin{frame}[fragile]{Física — Caminata aleatoria 1D}
\begin{minted}{python}
import random

def random_walk(n=1000):
    x = 0
    tray = [x]
    for _ in range(n):
        x += 1 if random.random() < 0.5 else -1
        tray.append(x)
    return tray

tray = random_walk(1000)
print("pos final:", tray[-1])
\end{minted}
\end{frame}

%---------------------------- EJECUCIÓN Y ARCHIVOS ----------------------------
\begin{frame}[fragile]{Cómo ejecutar y organizar (WSL/Linux)}
\begin{minted}{bash}
# Ejecutar un script
python3 script.py

# Guardar/leer datos simples (CSV)
python3 - << 'PY'
import csv
rows = [{"t":0, "y":1.0}, {"t":1, "y":1.5}]
with open("datos.csv","w", newline="") as f:
    w = csv.DictWriter(f, fieldnames=["t","y"])
    w.writeheader(); w.writerows(rows)
print("Escribí datos.csv")
PY
\end{minted}
\end{frame}

%---------------------------- TAREA BASE ----------------------------
\begin{frame}{Tarea base (para la próxima)}
\begin{itemize}
  \item Elige uno de los cuatro \textbf{snippets por área} y:
  \begin{itemize}
    \item Refactoriza en funciones limpias.
    \item Añade \textbf{tests} mínimos (incluso \texttt{assert} simples).
    \item Genera un gráfico o salida tabular (según corresponda).
  \end{itemize}
  \item Mide tiempo de ejecución con \texttt{time.perf\_counter()}.
  \item \textbf{Bonus}: intenta paralelizar algo si tiene sentido (p.ej., evaluar varias ventanas en paralelo).
\end{itemize}
\end{frame}

%---------------------------- CIERRE ----------------------------
\begin{frame}{Cierre y próximos pasos}
\begin{itemize}
  \item Ya tienes lo esencial de Python 3 y \emph{un} ejemplo con procesos.
  \item Próximas sesiones: empaquetar, automatizar y escalar al clúster (Leftraru).
  \item Mantén los scripts simples, \textbf{medibles} y con salidas claras (gráficos/CSV).
\end{itemize}
\end{frame}


\end{document}